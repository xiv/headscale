{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to headscale","text":"<p>Headscale is an open source, self-hosted implementation of the Tailscale control server.</p> <p>This page contains the documentation for the latest version of headscale. Please also check our FAQ.</p> <p>Join our Discord server for a chat and community support.</p>"},{"location":"#design-goal","title":"Design goal","text":"<p>Headscale aims to implement a self-hosted, open source alternative to the Tailscale control server. Headscale's goal is to provide self-hosters and hobbyists with an open-source server they can use for their projects and labs. It implements a narrow scope, a single Tailscale network (tailnet), suitable for a personal use, or a small open-source organisation.</p>"},{"location":"#supporting-headscale","title":"Supporting headscale","text":"<p>Please see Sponsor for more information.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Headscale is \"Open Source, acknowledged contribution\", this means that any contribution will have to be discussed with the Maintainers before being submitted.</p> <p>Please see Contributing for more information.</p>"},{"location":"#about","title":"About","text":"<p>Headscale is maintained by Kristoffer Dalby and Juan Font.</p>"},{"location":"about/clients/","title":"Client and operating system support","text":"<p>We aim to support the last 10 releases of the Tailscale client on all provided operating systems and platforms. Some platforms might require additional configuration to connect with headscale.</p> OS Supports headscale Linux Yes OpenBSD Yes FreeBSD Yes Windows Yes (see docs and <code>/windows</code> on your headscale for more information) Android Yes (see docs for more information) macOS Yes (see docs and <code>/apple</code> on your headscale for more information) iOS Yes (see docs and <code>/apple</code> on your headscale for more information) tvOS Yes (see docs and <code>/apple</code> on your headscale for more information)"},{"location":"about/contributing/","title":"Contributing","text":"<p>Headscale is \"Open Source, acknowledged contribution\", this means that any contribution will have to be discussed with the maintainers before being added to the project. This model has been chosen to reduce the risk of burnout by limiting the maintenance overhead of reviewing and validating third-party code.</p>"},{"location":"about/contributing/#why-do-we-have-this-model","title":"Why do we have this model?","text":"<p>Headscale has a small maintainer team that tries to balance working on the project, fixing bugs and reviewing contributions.</p> <p>When we work on issues ourselves, we develop first hand knowledge of the code and it makes it possible for us to maintain and own the code as the project develops.</p> <p>Code contributions are seen as a positive thing. People enjoy and engage with our project, but it also comes with some challenges; we have to understand the code, we have to understand the feature, we might have to become familiar with external libraries or services and we think about security implications. All those steps are required during the reviewing process. After the code has been merged, the feature has to be maintained. Any changes reliant on external services must be updated and expanded accordingly.</p> <p>The review and day-1 maintenance adds a significant burden on the maintainers. Often we hope that the contributor will help out, but we found that most of the time, they disappear after their new feature was added.</p> <p>This means that when someone contributes, we are mostly happy about it, but we do have to run it through a series of checks to establish if we actually can maintain this feature.</p>"},{"location":"about/contributing/#what-do-we-require","title":"What do we require?","text":"<p>A general description is provided here and an explicit list is provided in our pull request template.</p> <p>All new features have to start out with a design document, which should be discussed on the issue tracker (not discord). It should include a use case for the feature, how it can be implemented, who will implement it and a plan for maintaining it.</p> <p>All features have to be end-to-end tested (integration tests) and have good unit test coverage to ensure that they work as expected. This will also ensure that the feature continues to work as expected over time. If a change cannot be tested, a strong case for why this is not possible needs to be presented.</p> <p>The contributor should help to maintain the feature over time. In case the feature is not maintained probably, the maintainers reserve themselves the right to remove features they redeem as unmaintainable. This should help to improve the quality of the software and keep it in a maintainable state.</p>"},{"location":"about/contributing/#bug-fixes","title":"Bug fixes","text":"<p>Headscale is open to code contributions for bug fixes without discussion.</p>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>If you find mistakes in the documentation, please submit a fix to the documentation.</p>"},{"location":"about/faq/","title":"Frequently Asked Questions","text":""},{"location":"about/faq/#what-is-the-design-goal-of-headscale","title":"What is the design goal of headscale?","text":"<p>Headscale aims to implement a self-hosted, open source alternative to the Tailscale control server. Headscale's goal is to provide self-hosters and hobbyists with an open-source server they can use for their projects and labs. It implements a narrow scope, a single Tailscale network (tailnet), suitable for a personal use, or a small open-source organisation.</p>"},{"location":"about/faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>Headscale is \"Open Source, acknowledged contribution\", this means that any contribution will have to be discussed with the Maintainers before being submitted.</p> <p>Please see Contributing for more information.</p>"},{"location":"about/faq/#why-is-acknowledged-contribution-the-chosen-model","title":"Why is 'acknowledged contribution' the chosen model?","text":"<p>Both maintainers have full-time jobs and families, and we want to avoid burnout. We also want to avoid frustration from contributors when their PRs are not accepted.</p> <p>We are more than happy to exchange emails, or to have dedicated calls before a PR is submitted.</p>"},{"location":"about/faq/#whenwhy-is-feature-x-going-to-be-implemented","title":"When/Why is Feature X going to be implemented?","text":"<p>We don't know. We might be working on it. If you're interested in contributing, please post a feature request about it.</p> <p>Please be aware that there are a number of reasons why we might not accept specific contributions:</p> <ul> <li>It is not possible to implement the feature in a way that makes sense in a self-hosted environment.</li> <li>Given that we are reverse-engineering Tailscale to satisfy our own curiosity, we might be interested in implementing the feature ourselves.</li> <li>You are not sending unit and integration tests with it.</li> </ul>"},{"location":"about/faq/#do-you-support-y-method-of-deploying-headscale","title":"Do you support Y method of deploying headscale?","text":"<p>We currently support deploying headscale using our binaries and the DEB packages. Visit our installation guide using official releases for more information.</p> <p>In addition to that, you may use packages provided by the community or from distributions. Learn more in the installation guide using community packages.</p> <p>For convenience, we also build Docker images with headscale. But please be aware that we don't officially support deploying headscale using Docker. On our Discord server we have a \"docker-issues\" channel where you can ask for Docker-specific help to the community.</p>"},{"location":"about/faq/#which-database-should-i-use","title":"Which database should I use?","text":"<p>We recommend the use of SQLite as database for headscale:</p> <ul> <li>SQLite is simple to setup and easy to use</li> <li>It scales well for all of headscale's usecases</li> <li>Development and testing happens primarily on SQLite</li> <li>PostgreSQL is still supported, but is considered to be in \"maintenance mode\"</li> </ul> <p>The headscale project itself does not provide a tool to migrate from PostgreSQL to SQLite. Please have a look at the related tools documentation for migration tooling provided by the community.</p>"},{"location":"about/faq/#why-is-my-reverse-proxy-not-working-with-headscale","title":"Why is my reverse proxy not working with headscale?","text":"<p>We don't know. We don't use reverse proxies with headscale ourselves, so we don't have any experience with them. We have community documentation on how to configure various reverse proxies, and a dedicated \"reverse-proxy-issues\" channel on our Discord server where you can ask for help to the community.</p>"},{"location":"about/faq/#can-i-use-headscale-and-tailscale-on-the-same-machine","title":"Can I use headscale and tailscale on the same machine?","text":"<p>Running headscale on a machine that is also in the tailnet can cause problems with subnet routers, traffic relay nodes, and MagicDNS. It might work, but it is not supported.</p>"},{"location":"about/features/","title":"Features","text":"<p>Headscale aims to implement a self-hosted, open source alternative to the Tailscale control server. Headscale's goal is to provide self-hosters and hobbyists with an open-source server they can use for their projects and labs. This page provides on overview of headscale's feature and compatibility with the Tailscale control server:</p> <ul> <li> Full \"base\" support of Tailscale's features</li> <li> Node registration<ul> <li> Interactive</li> <li> Pre authenticated key</li> </ul> </li> <li> DNS<ul> <li> MagicDNS</li> <li> Global and restricted nameservers (split DNS)</li> <li> search domains</li> <li> Extra DNS records (headscale only)</li> </ul> </li> <li> Taildrop (File Sharing)</li> <li> Routing advertising (including exit nodes)</li> <li> Dual stack (IPv4 and IPv6)</li> <li> Ephemeral nodes</li> <li> Embedded DERP server</li> <li> Access control lists (GitHub label \"policy\")<ul> <li> ACL management via API</li> <li> <code>autogroup:internet</code></li> <li> <code>autogroup:self</code></li> <li> <code>autogroup:member</code></li> </ul> </li> <li> Node registration using Single-Sign-On (OpenID Connect) (GitHub label \"OIDC\")<ul> <li> Basic registration</li> <li> Update user profile from identity provider</li> <li> Dynamic ACL support</li> <li> OIDC groups cannot be used in ACLs</li> </ul> </li> <li> Funnel (#1040)</li> <li> Serve (#1234)</li> </ul>"},{"location":"about/help/","title":"Getting help","text":"<p>Join our Discord server for announcements and community support.</p> <p>Please report bugs via GitHub issues</p>"},{"location":"about/releases/","title":"Releases","text":"<p>All headscale releases are available on the GitHub release page. Those releases are available as binaries for various platforms and architectures, packages for Debian based systems and source code archives. Container images are available on Docker Hub.</p> <p>An Atom/RSS feed of headscale releases is available here.</p> <p>See the \"announcements\" channel on our Discord server for news about headscale.</p>"},{"location":"about/sponsor/","title":"Sponsor","text":"<p>If you like to support the development of headscale, please consider a donation via ko-fi.com/headscale. Thank you!</p>"},{"location":"ref/acls/","title":"ACLs","text":"<p>Headscale implements the same policy ACLs as Tailscale.com, adapted to the self-hosted environment.</p> <p>For instance, instead of referring to users when defining groups you must use users (which are the equivalent to user/logins in Tailscale.com).</p> <p>Please check https://tailscale.com/kb/1018/acls/ for further information.</p> <p>When using ACL's the User borders are no longer applied. All machines whichever the User have the ability to communicate with other hosts as long as the ACL's permits this exchange.</p>"},{"location":"ref/acls/#acls-use-case-example","title":"ACLs use case example","text":"<p>Let's build an example use case for a small business (It may be the place where ACL's are the most useful).</p> <p>We have a small company with a boss, an admin, two developers and an intern.</p> <p>The boss should have access to all servers but not to the user's hosts. Admin should also have access to all hosts except that their permissions should be limited to maintaining the hosts (for example purposes). The developers can do anything they want on dev hosts but only watch on productions hosts. Intern can only interact with the development servers.</p> <p>There's an additional server that acts as a router, connecting the VPN users to an internal network <code>10.20.0.0/16</code>. Developers must have access to those internal resources.</p> <p>Each user have at least a device connected to the network and we have some servers.</p> <ul> <li>database.prod</li> <li>database.dev</li> <li>app-server1.prod</li> <li>app-server1.dev</li> <li>billing.internal</li> <li>router.internal</li> </ul> <p></p>"},{"location":"ref/acls/#acl-setup","title":"ACL setup","text":"<p>ACLs have to be written in huJSON.</p> <p>When registering the servers we will need to add the flag <code>--advertise-tags=tag:&lt;tag1&gt;,tag:&lt;tag2&gt;</code>, and the user that is registering the server should be allowed to do it. Since anyone can add tags to a server they can register, the check of the tags is done on headscale server and only valid tags are applied. A tag is valid if the user that is registering it is allowed to do it.</p> <p>To use ACLs in headscale, you must edit your <code>config.yaml</code> file. In there you will find a <code>policy.path</code> parameter. This will need to point to your ACL file. More info on how these policies are written can be found here.</p> <p>Please reload or restart Headscale after updating the ACL file. Headscale may be reloaded either via its systemd service (<code>sudo systemctl reload headscale</code>) or by sending a SIGHUP signal (<code>sudo kill -HUP $(pidof headscale)</code>) to the main process. Headscale logs the result of ACL policy processing after each reload.</p> <p>Here are the ACL's to implement the same permissions as above:</p> acl.json<pre><code>{\n  // groups are collections of users having a common scope. A user can be in multiple groups\n  // groups cannot be composed of groups\n  \"groups\": {\n    \"group:boss\": [\"boss\"],\n    \"group:dev\": [\"dev1\", \"dev2\"],\n    \"group:admin\": [\"admin1\"],\n    \"group:intern\": [\"intern1\"]\n  },\n  // tagOwners in tailscale is an association between a TAG and the people allowed to set this TAG on a server.\n  // This is documented [here](https://tailscale.com/kb/1068/acl-tags#defining-a-tag)\n  // and explained [here](https://tailscale.com/blog/rbac-like-it-was-meant-to-be/)\n  \"tagOwners\": {\n    // the administrators can add servers in production\n    \"tag:prod-databases\": [\"group:admin\"],\n    \"tag:prod-app-servers\": [\"group:admin\"],\n\n    // the boss can tag any server as internal\n    \"tag:internal\": [\"group:boss\"],\n\n    // dev can add servers for dev purposes as well as admins\n    \"tag:dev-databases\": [\"group:admin\", \"group:dev\"],\n    \"tag:dev-app-servers\": [\"group:admin\", \"group:dev\"]\n\n    // interns cannot add servers\n  },\n  // hosts should be defined using its IP addresses and a subnet mask.\n  // to define a single host, use a /32 mask. You cannot use DNS entries here,\n  // as they're prone to be hijacked by replacing their IP addresses.\n  // see https://github.com/tailscale/tailscale/issues/3800 for more information.\n  \"hosts\": {\n    \"postgresql.internal\": \"10.20.0.2/32\",\n    \"webservers.internal\": \"10.20.10.1/29\"\n  },\n  \"acls\": [\n    // boss have access to all servers\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:boss\"],\n      \"dst\": [\n        \"tag:prod-databases:*\",\n        \"tag:prod-app-servers:*\",\n        \"tag:internal:*\",\n        \"tag:dev-databases:*\",\n        \"tag:dev-app-servers:*\"\n      ]\n    },\n\n    // admin have only access to administrative ports of the servers, in tcp/22\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:admin\"],\n      \"proto\": \"tcp\",\n      \"dst\": [\n        \"tag:prod-databases:22\",\n        \"tag:prod-app-servers:22\",\n        \"tag:internal:22\",\n        \"tag:dev-databases:22\",\n        \"tag:dev-app-servers:22\"\n      ]\n    },\n\n    // we also allow admin to ping the servers\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:admin\"],\n      \"proto\": \"icmp\",\n      \"dst\": [\n        \"tag:prod-databases:*\",\n        \"tag:prod-app-servers:*\",\n        \"tag:internal:*\",\n        \"tag:dev-databases:*\",\n        \"tag:dev-app-servers:*\"\n      ]\n    },\n\n    // developers have access to databases servers and application servers on all ports\n    // they can only view the applications servers in prod and have no access to databases servers in production\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:dev\"],\n      \"dst\": [\n        \"tag:dev-databases:*\",\n        \"tag:dev-app-servers:*\",\n        \"tag:prod-app-servers:80,443\"\n      ]\n    },\n    // developers have access to the internal network through the router.\n    // the internal network is composed of HTTPS endpoints and Postgresql\n    // database servers. There's an additional rule to allow traffic to be\n    // forwarded to the internal subnet, 10.20.0.0/16. See this issue\n    // https://github.com/juanfont/headscale/issues/502\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:dev\"],\n      \"dst\": [\"10.20.0.0/16:443,5432\", \"router.internal:0\"]\n    },\n\n    // servers should be able to talk to database in tcp/5432. Database should not be able to initiate connections to\n    // applications servers\n    {\n      \"action\": \"accept\",\n      \"src\": [\"tag:dev-app-servers\"],\n      \"proto\": \"tcp\",\n      \"dst\": [\"tag:dev-databases:5432\"]\n    },\n    {\n      \"action\": \"accept\",\n      \"src\": [\"tag:prod-app-servers\"],\n      \"dst\": [\"tag:prod-databases:5432\"]\n    },\n\n    // interns have access to dev-app-servers only in reading mode\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:intern\"],\n      \"dst\": [\"tag:dev-app-servers:80,443\"]\n    },\n\n    // We still have to allow internal users communications since nothing guarantees that each user have\n    // their own users.\n    { \"action\": \"accept\", \"src\": [\"boss\"], \"dst\": [\"boss:*\"] },\n    { \"action\": \"accept\", \"src\": [\"dev1\"], \"dst\": [\"dev1:*\"] },\n    { \"action\": \"accept\", \"src\": [\"dev2\"], \"dst\": [\"dev2:*\"] },\n    { \"action\": \"accept\", \"src\": [\"admin1\"], \"dst\": [\"admin1:*\"] },\n    { \"action\": \"accept\", \"src\": [\"intern1\"], \"dst\": [\"intern1:*\"] }\n  ]\n}\n</code></pre>"},{"location":"ref/configuration/","title":"Configuration","text":"<ul> <li>Headscale loads its configuration from a YAML file</li> <li>It searches for <code>config.yaml</code> in the following paths:<ul> <li><code>/etc/headscale</code></li> <li><code>$HOME/.headscale</code></li> <li>the current working directory</li> </ul> </li> <li>Use the command line flag <code>-c</code>, <code>--config</code> to load the configuration from a different path</li> <li>Validate the configuration file with: <code>headscale configtest</code></li> </ul> <p>Get the example configuration from the GitHub repository</p> <p>Always select the same GitHub tag as the released version you use to ensure you have the correct example configuration. The <code>main</code> branch might contain unreleased changes.</p> View on GitHubDownload with <code>wget</code>Download with <code>curl</code> <ul> <li>Development version: https://github.com/juanfont/headscale/blob/main/config-example.yaml</li> <li>Version 0.25.0: https://github.com/juanfont/headscale/blob/v0.25.0/config-example.yaml</li> </ul> <pre><code># Development version\nwget -O config.yaml https://raw.githubusercontent.com/juanfont/headscale/main/config-example.yaml\n\n# Version 0.25.0\nwget -O config.yaml https://raw.githubusercontent.com/juanfont/headscale/v0.25.0/config-example.yaml\n</code></pre> <pre><code># Development version\ncurl -o config.yaml https://raw.githubusercontent.com/juanfont/headscale/main/config-example.yaml\n\n# Version 0.25.0\ncurl -o config.yaml https://raw.githubusercontent.com/juanfont/headscale/v0.25.0/config-example.yaml\n</code></pre>"},{"location":"ref/dns/","title":"DNS","text":"<p>Headscale supports most DNS features from Tailscale. DNS related settings can be configured within <code>dns</code> section of the configuration file.</p>"},{"location":"ref/dns/#setting-extra-dns-records","title":"Setting extra DNS records","text":"<p>Headscale allows to set extra DNS records which are made available via MagicDNS. Extra DNS records can be configured either via static entries in the configuration file or from a JSON file that Headscale continuously watches for changes:</p> <ul> <li>Use the <code>dns.extra_records</code> option in the configuration file for entries that are static and   don't change while Headscale is running. Those entries are processed when Headscale is starting up and changes to the   configuration require a restart of Headscale.</li> <li>For dynamic DNS records that may be added, updated or removed while Headscale is running or DNS records that are   generated by scripts the option <code>dns.extra_records_path</code> in the configuration file is useful.   Set it to the absolute path of the JSON file containing DNS records and Headscale processes this file as it detects   changes.</li> </ul> <p>An example use case is to serve multiple apps on the same host via a reverse proxy like NGINX, in this case a Prometheus monitoring stack. This allows to nicely access the service with \"http://grafana.myvpn.example.com\" instead of the hostname and port combination \"http://hostname-in-magic-dns.myvpn.example.com:3000\".</p> <p>Limitations</p> <p>Currently, only A and AAAA records are processed by Tailscale.</p> <ol> <li> <p>Configure extra DNS records using one of the available configuration options:</p> Static entries, via <code>dns.extra_records</code>Dynamic entries, via <code>dns.extra_records_path</code> config.yaml<pre><code>dns:\n  ...\n  extra_records:\n    - name: \"grafana.myvpn.example.com\"\n      type: \"A\"\n      value: \"100.64.0.3\"\n\n    - name: \"prometheus.myvpn.example.com\"\n      type: \"A\"\n      value: \"100.64.0.3\"\n  ...\n</code></pre> <p>Restart your headscale instance.</p> extra-records.json<pre><code>[\n  {\n    \"name\": \"grafana.myvpn.example.com\",\n    \"type\": \"A\",\n    \"value\": \"100.64.0.3\"\n  },\n  {\n    \"name\": \"prometheus.myvpn.example.com\",\n    \"type\": \"A\",\n    \"value\": \"100.64.0.3\"\n  }\n]\n</code></pre> <p>Headscale picks up changes to the above JSON file automatically.</p> <p>Good to know</p> <ul> <li>The <code>dns.extra_records_path</code> option in the configuration file needs to reference the   JSON file containing extra DNS records.</li> <li>Be sure to \"sort keys\" and produce a stable output in case you generate the JSON file with a script.   Headscale uses a checksum to detect changes to the file and a stable output avoids unnecessary processing.</li> </ul> </li> <li> <p>Verify that DNS records are properly set using the DNS querying tool of your choice:</p> Query with digQuery with drill <pre><code>dig +short grafana.myvpn.example.com\n100.64.0.3\n</code></pre> <pre><code>drill -Q grafana.myvpn.example.com\n100.64.0.3\n</code></pre> </li> <li> <p>Optional: Setup the reverse proxy</p> <p>The motivating example here was to be able to access internal monitoring services on the same host without specifying a port, depicted as NGINX configuration snippet:</p> nginx.conf<pre><code>server {\n    listen 80;\n    listen [::]:80;\n\n    server_name grafana.myvpn.example.com;\n\n    location / {\n        proxy_pass http://localhost:3000;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n\n}\n</code></pre> </li> </ol>"},{"location":"ref/exit-node/","title":"Exit Nodes","text":""},{"location":"ref/exit-node/#on-the-node","title":"On the node","text":"<p>Register the node and make it advertise itself as an exit node:</p> <pre><code>$ sudo tailscale up --login-server https://headscale.example.com --advertise-exit-node\n</code></pre> <p>If the node is already registered, it can advertise exit capabilities like this:</p> <pre><code>$ sudo tailscale set --advertise-exit-node\n</code></pre> <p>To use a node as an exit node, IP forwarding must be enabled on the node. Check the official Tailscale documentation for how to enable IP forwarding.</p>"},{"location":"ref/exit-node/#on-the-control-server","title":"On the control server","text":"<pre><code>$ headscale nodes list-routes\nID | Hostname           | Approved | Available       | Serving\n1  | ts-head-ruqsg8     |          | 0.0.0.0/0, ::/0 |\n2  | ts-unstable-fq7ob4 |          | 0.0.0.0/0, ::/0 |\n\n# Note that for exit nodes, it is sufficient to approve either the IPv4 or IPv6 route. The other will be added automatically.\n$ headscale nodes approve-routes --identifier 1 --routes 0.0.0.0/0\nNode updated\n\n$ headscale nodes list-routes\nID | Hostname           | Approved        | Available       | Serving\n1  | ts-head-ruqsg8     | 0.0.0.0/0, ::/0 | 0.0.0.0/0, ::/0 | 0.0.0.0/0, ::/0\n2  | ts-unstable-fq7ob4 |                 | 0.0.0.0/0, ::/0 |\n</code></pre>"},{"location":"ref/exit-node/#on-the-client","title":"On the client","text":"<p>The exit node can now be used with:</p> <pre><code>$ sudo tailscale set --exit-node phobos\n</code></pre> <p>Check the official Tailscale documentation for how to do it on your device.</p>"},{"location":"ref/oidc/","title":"Configuring headscale to use OIDC authentication","text":"<p>In order to authenticate users through a centralized solution one must enable the OIDC integration.</p> <p>Known limitations:</p> <ul> <li>No dynamic ACL support</li> <li>OIDC groups cannot be used in ACLs</li> </ul>"},{"location":"ref/oidc/#basic-configuration","title":"Basic configuration","text":"<p>In your <code>config.yaml</code>, customize this to your liking:</p> config.yaml<pre><code>oidc:\n  # Block further startup until the OIDC provider is healthy and available\n  only_start_if_oidc_is_available: true\n  # Specified by your OIDC provider\n  issuer: \"https://your-oidc.issuer.com/path\"\n  # Specified/generated by your OIDC provider\n  client_id: \"your-oidc-client-id\"\n  client_secret: \"your-oidc-client-secret\"\n  # alternatively, set `client_secret_path` to read the secret from the file.\n  # It resolves environment variables, making integration to systemd's\n  # `LoadCredential` straightforward:\n  #client_secret_path: \"${CREDENTIALS_DIRECTORY}/oidc_client_secret\"\n  # as third option, it's also possible to load the oidc secret from environment variables\n  # set HEADSCALE_OIDC_CLIENT_SECRET to the required value\n\n  # Customize the scopes used in the OIDC flow, defaults to \"openid\", \"profile\" and \"email\" and add custom query\n  # parameters to the Authorize Endpoint request. Scopes default to \"openid\", \"profile\" and \"email\".\n  scope: [\"openid\", \"profile\", \"email\", \"custom\"]\n  # Optional: Passed on to the browser login request \u2013 used to tweak behaviour for the OIDC provider\n  extra_params:\n    domain_hint: example.com\n\n  # Optional: List allowed principal domains and/or users. If an authenticated user's domain is not in this list,\n  # the authentication request will be rejected.\n  allowed_domains:\n    - example.com\n  # Optional. Note that groups from Keycloak have a leading '/'.\n  allowed_groups:\n    - /headscale\n  # Optional.\n  allowed_users:\n    - alice@example.com\n\n  # Optional: PKCE (Proof Key for Code Exchange) configuration\n  # PKCE adds an additional layer of security to the OAuth 2.0 authorization code flow\n  # by preventing authorization code interception attacks\n  # See https://datatracker.ietf.org/doc/html/rfc7636\n  pkce:\n    # Enable or disable PKCE support (default: false)\n    enabled: false\n    # PKCE method to use:\n    # - plain: Use plain code verifier\n    # - S256: Use SHA256 hashed code verifier (default, recommended)\n    method: S256\n</code></pre>"},{"location":"ref/oidc/#azure-ad-example","title":"Azure AD example","text":"<p>In order to integrate headscale with Azure Active Directory, we'll need to provision an App Registration with the correct scopes and redirect URI. Here with Terraform:</p> terraform.hcl<pre><code>resource \"azuread_application\" \"headscale\" {\n  display_name = \"Headscale\"\n\n  sign_in_audience = \"AzureADMyOrg\"\n  fallback_public_client_enabled = false\n\n  required_resource_access {\n    // Microsoft Graph\n    resource_app_id = \"00000003-0000-0000-c000-000000000000\"\n\n    resource_access {\n      // scope: profile\n      id   = \"14dad69e-099b-42c9-810b-d002981feec1\"\n      type = \"Scope\"\n    }\n    resource_access {\n      // scope: openid\n      id   = \"37f7f235-527c-4136-accd-4a02d197296e\"\n      type = \"Scope\"\n    }\n    resource_access {\n      // scope: email\n      id   = \"64a6cdd6-aab1-4aaf-94b8-3cc8405e90d0\"\n      type = \"Scope\"\n    }\n  }\n  web {\n    # Points at your running headscale instance\n    redirect_uris = [\"https://headscale.example.com/oidc/callback\"]\n\n    implicit_grant {\n      access_token_issuance_enabled = false\n      id_token_issuance_enabled = true\n    }\n  }\n\n  group_membership_claims = [\"SecurityGroup\"]\n  optional_claims {\n    # Expose group memberships\n    id_token {\n      name = \"groups\"\n    }\n  }\n}\n\nresource \"azuread_application_password\" \"headscale-application-secret\" {\n  display_name          = \"Headscale Server\"\n  application_object_id = azuread_application.headscale.object_id\n}\n\nresource \"azuread_service_principal\" \"headscale\" {\n  application_id = azuread_application.headscale.application_id\n}\n\nresource \"azuread_service_principal_password\" \"headscale\" {\n  service_principal_id = azuread_service_principal.headscale.id\n  end_date_relative    = \"44640h\"\n}\n\noutput \"headscale_client_id\" {\n  value = azuread_application.headscale.application_id\n}\n\noutput \"headscale_client_secret\" {\n  value = azuread_application_password.headscale-application-secret.value\n}\n</code></pre> <p>And in your headscale <code>config.yaml</code>:</p> config.yaml<pre><code>oidc:\n  issuer: \"https://login.microsoftonline.com/&lt;tenant-UUID&gt;/v2.0\"\n  client_id: \"&lt;client-id-from-terraform&gt;\"\n  client_secret: \"&lt;client-secret-from-terraform&gt;\"\n\n  # Optional: add \"groups\"\n  scope: [\"openid\", \"profile\", \"email\"]\n  extra_params:\n    # Use your own domain, associated with Azure AD\n    domain_hint: example.com\n    # Optional: Force the Azure AD account picker\n    prompt: select_account\n</code></pre>"},{"location":"ref/oidc/#google-oauth-example","title":"Google OAuth Example","text":"<p>In order to integrate headscale with Google, you'll need to have a Google Cloud Console account.</p> <p>Google OAuth has a verification process if you need to have users authenticate who are outside of your domain. If you only need to authenticate users from your domain name (ie <code>@example.com</code>), you don't need to go through the verification process.</p> <p>However if you don't have a domain, or need to add users outside of your domain, you can manually add emails via Google Console.</p>"},{"location":"ref/oidc/#steps","title":"Steps","text":"<ol> <li>Go to Google Console and login or create an account if you don't have one.</li> <li>Create a project (if you don't already have one).</li> <li>On the left hand menu, go to <code>APIs and services</code> -&gt; <code>Credentials</code></li> <li>Click <code>Create Credentials</code> -&gt; <code>OAuth client ID</code></li> <li>Under <code>Application Type</code>, choose <code>Web Application</code></li> <li>For <code>Name</code>, enter whatever you like</li> <li>Under <code>Authorised redirect URIs</code>, use <code>https://example.com/oidc/callback</code>, replacing example.com with your headscale URL.</li> <li>Click <code>Save</code> at the bottom of the form</li> <li>Take note of the <code>Client ID</code> and <code>Client secret</code>, you can also download it for reference if you need it.</li> <li>Edit your headscale config, under <code>oidc</code>, filling in your <code>client_id</code> and <code>client_secret</code>:     config.yaml<pre><code>oidc:\n  issuer: \"https://accounts.google.com\"\n  client_id: \"\"\n  client_secret: \"\"\n  scope: [\"openid\", \"profile\", \"email\"]\n</code></pre></li> </ol> <p>You can also use <code>allowed_domains</code> and <code>allowed_users</code> to restrict the users who can authenticate.</p>"},{"location":"ref/remote-cli/","title":"Controlling headscale with remote CLI","text":"<p>This documentation has the goal of showing a user how-to control a headscale instance from a remote machine with the <code>headscale</code> command line binary.</p>"},{"location":"ref/remote-cli/#prerequisite","title":"Prerequisite","text":"<ul> <li>A workstation to run <code>headscale</code> (any supported platform, e.g. Linux).</li> <li>A headscale server with gRPC enabled.</li> <li>Connections to the gRPC port (default: <code>50443</code>) are allowed.</li> <li>Remote access requires an encrypted connection via TLS.</li> <li>An API key to authenticate with the headscale server.</li> </ul>"},{"location":"ref/remote-cli/#create-an-api-key","title":"Create an API key","text":"<p>We need to create an API key to authenticate with the remote headscale server when using it from our workstation.</p> <p>To create an API key, log into your headscale server and generate a key:</p> <pre><code>headscale apikeys create --expiration 90d\n</code></pre> <p>Copy the output of the command and save it for later. Please note that you can not retrieve a key again, if the key is lost, expire the old one, and create a new key.</p> <p>To list the keys currently associated with the server:</p> <pre><code>headscale apikeys list\n</code></pre> <p>and to expire a key:</p> <pre><code>headscale apikeys expire --prefix \"&lt;PREFIX&gt;\"\n</code></pre>"},{"location":"ref/remote-cli/#download-and-configure-headscale","title":"Download and configure headscale","text":"<ol> <li> <p>Download the <code>headscale</code> binary from GitHub's release page. Make     sure to use the same version as on the server.</p> </li> <li> <p>Put the binary somewhere in your <code>PATH</code>, e.g. <code>/usr/local/bin/headscale</code></p> </li> <li> <p>Make <code>headscale</code> executable:</p> <pre><code>chmod +x /usr/local/bin/headscale\n</code></pre> </li> <li> <p>Provide the connection parameters for the remote headscale server either via a minimal YAML configuration file or via     environment variables:</p> Minimal YAML configuration fileEnvironment variables config.yaml<pre><code>cli:\n    address: &lt;HEADSCALE_ADDRESS&gt;:&lt;PORT&gt;\n    api_key: &lt;API_KEY_FROM_PREVIOUS_STEP&gt;\n</code></pre> <pre><code>export HEADSCALE_CLI_ADDRESS=\"&lt;HEADSCALE_ADDRESS&gt;:&lt;PORT&gt;\"\nexport HEADSCALE_CLI_API_KEY=\"&lt;API_KEY_FROM_PREVIOUS_STEP&gt;\"\n</code></pre> <p>Bug</p> <p>Headscale currently requires at least an empty configuration file when environment variables are used to specify connection details. See issue 2193 for more information.</p> <p>This instructs the <code>headscale</code> binary to connect to a remote instance at <code>&lt;HEADSCALE_ADDRESS&gt;:&lt;PORT&gt;</code>, instead of connecting to the local instance.</p> </li> <li> <p>Test the connection</p> <p>Let us run the headscale command to verify that we can connect by listing our nodes:</p> <pre><code>headscale nodes list\n</code></pre> <p>You should now be able to see a list of your nodes from your workstation, and you can now control the headscale server from your workstation.</p> </li> </ol>"},{"location":"ref/remote-cli/#behind-a-proxy","title":"Behind a proxy","text":"<p>It is possible to run the gRPC remote endpoint behind a reverse proxy, like Nginx, and have it run on the same port as headscale.</p> <p>While this is not a supported feature, an example on how this can be set up on NixOS is shown here.</p>"},{"location":"ref/remote-cli/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Make sure you have the same headscale version on your server and workstation.</li> <li>Ensure that connections to the gRPC port are allowed.</li> <li>Verify that your TLS certificate is valid and trusted.</li> <li>If you don't have access to a trusted certificate (e.g. from Let's Encrypt), either:<ul> <li>Add your self-signed certificate to the trust store of your OS or</li> <li>Disable certificate verification by either setting <code>cli.insecure: true</code> in the configuration file or by setting   <code>HEADSCALE_CLI_INSECURE=1</code> via an environment variable. We do not recommend to disable certificate validation.</li> </ul> </li> </ul>"},{"location":"ref/tls/","title":"Running the service via TLS (optional)","text":""},{"location":"ref/tls/#bring-your-own-certificate","title":"Bring your own certificate","text":"<p>Headscale can be configured to expose its web service via TLS. To configure the certificate and key file manually, set the <code>tls_cert_path</code> and <code>tls_cert_path</code> configuration parameters. If the path is relative, it will be interpreted as relative to the directory the configuration file was read from.</p> config.yaml<pre><code>tls_cert_path: \"\"\ntls_key_path: \"\"\n</code></pre> <p>The certificate should contain the full chain, else some clients, like the Tailscale Android client, will reject it.</p>"},{"location":"ref/tls/#lets-encrypt-acme","title":"Let's Encrypt / ACME","text":"<p>To get a certificate automatically via Let's Encrypt, set <code>tls_letsencrypt_hostname</code> to the desired certificate hostname. This name must resolve to the IP address(es) headscale is reachable on (i.e., it must correspond to the <code>server_url</code> configuration parameter). The certificate and Let's Encrypt account credentials will be stored in the directory configured in <code>tls_letsencrypt_cache_dir</code>. If the path is relative, it will be interpreted as relative to the directory the configuration file was read from.</p> config.yaml<pre><code>tls_letsencrypt_hostname: \"\"\ntls_letsencrypt_listen: \":http\"\ntls_letsencrypt_cache_dir: \".cache\"\ntls_letsencrypt_challenge_type: HTTP-01\n</code></pre>"},{"location":"ref/tls/#challenge-types","title":"Challenge types","text":"<p>Headscale only supports two values for <code>tls_letsencrypt_challenge_type</code>: <code>HTTP-01</code> (default) and <code>TLS-ALPN-01</code>.</p>"},{"location":"ref/tls/#http-01","title":"HTTP-01","text":"<p>For <code>HTTP-01</code>, headscale must be reachable on port 80 for the Let's Encrypt automated validation, in addition to whatever port is configured in <code>listen_addr</code>. By default, headscale listens on port 80 on all local IPs for Let's Encrypt automated validation.</p> <p>If you need to change the ip and/or port used by headscale for the Let's Encrypt validation process, set <code>tls_letsencrypt_listen</code> to the appropriate value. This can be handy if you are running headscale as a non-root user (or can't run <code>setcap</code>). Keep in mind, however, that Let's Encrypt will only connect to port 80 for the validation callback, so if you change <code>tls_letsencrypt_listen</code> you will also need to configure something else (e.g. a firewall rule) to forward the traffic from port 80 to the ip:port combination specified in <code>tls_letsencrypt_listen</code>.</p>"},{"location":"ref/tls/#tls-alpn-01","title":"TLS-ALPN-01","text":"<p>For <code>TLS-ALPN-01</code>, headscale listens on the ip:port combination defined in <code>listen_addr</code>. Let's Encrypt will only connect to port 443 for the validation callback, so if <code>listen_addr</code> is not set to port 443, something else (e.g. a firewall rule) will be required to forward the traffic from port 443 to the ip:port combination specified in <code>listen_addr</code>.</p>"},{"location":"ref/tls/#technical-description","title":"Technical description","text":"<p>Headscale uses autocert, a Golang library providing ACME protocol verification, to facilitate certificate renewals via Let's Encrypt. Certificates will be renewed automatically, and the following can be expected:</p> <ul> <li>Certificates provided from Let's Encrypt have a validity of 3 months from date issued.</li> <li>Renewals are only attempted by headscale when 30 days or less remains until certificate expiry.</li> <li>Renewal attempts by autocert are triggered at a random interval of 30-60 minutes.</li> <li>No log output is generated when renewals are skipped, or successful.</li> </ul>"},{"location":"ref/tls/#checking-certificate-expiry","title":"Checking certificate expiry","text":"<p>If you want to validate that certificate renewal completed successfully, this can be done either manually, or through external monitoring software. Two examples of doing this manually:</p> <ol> <li>Open the URL for your headscale server in your browser of choice, and manually inspecting the expiry date of the certificate you receive.</li> <li>Or, check remotely from CLI using <code>openssl</code>:</li> </ol> <pre><code>$ openssl s_client -servername [hostname] -connect [hostname]:443 | openssl x509 -noout -dates\n(...)\nnotBefore=Feb  8 09:48:26 2024 GMT\nnotAfter=May  8 09:48:25 2024 GMT\n</code></pre>"},{"location":"ref/tls/#log-output-from-the-autocert-library","title":"Log output from the autocert library","text":"<p>As these log lines are from the autocert library, they are not strictly generated by headscale itself.</p> <pre><code>acme/autocert: missing server name\n</code></pre> <p>Likely caused by an incoming connection that does not specify a hostname, for example a <code>curl</code> request directly against the IP of the server, or an unexpected hostname.</p> <pre><code>acme/autocert: host \"[foo]\" not configured in HostWhitelist\n</code></pre> <p>Similarly to the above, this likely indicates an invalid incoming request for an incorrect hostname, commonly just the IP itself.</p> <p>The source code for autocert can be found here</p>"},{"location":"ref/integration/reverse-proxy/","title":"Running headscale behind a reverse proxy","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by headscale developers.</p> <p>It might be outdated and it might miss necessary steps.</p> <p>Running headscale behind a reverse proxy is useful when running multiple applications on the same server, and you want to reuse the same external IP and port - usually tcp/443 for HTTPS.</p>"},{"location":"ref/integration/reverse-proxy/#websockets","title":"WebSockets","text":"<p>The reverse proxy MUST be configured to support WebSockets to communicate with Tailscale clients.</p> <p>WebSockets support is also required when using the headscale embedded DERP server. In this case, you will also need to expose the UDP port used for STUN (by default, udp/3478). Please check our config-example.yaml.</p>"},{"location":"ref/integration/reverse-proxy/#cloudflare","title":"Cloudflare","text":"<p>Running headscale behind a cloudflare proxy or cloudflare tunnel is not supported and will not work as Cloudflare does not support WebSocket POSTs as required by the Tailscale protocol. See this issue</p>"},{"location":"ref/integration/reverse-proxy/#tls","title":"TLS","text":"<p>Headscale can be configured not to use TLS, leaving it to the reverse proxy to handle. Add the following configuration values to your headscale config file.</p> config.yaml<pre><code>server_url: https://&lt;YOUR_SERVER_NAME&gt; # This should be the FQDN at which headscale will be served\nlisten_addr: 0.0.0.0:8080\nmetrics_listen_addr: 0.0.0.0:9090\ntls_cert_path: \"\"\ntls_key_path: \"\"\n</code></pre>"},{"location":"ref/integration/reverse-proxy/#nginx","title":"nginx","text":"<p>The following example configuration can be used in your nginx setup, substituting values as necessary. <code>&lt;IP:PORT&gt;</code> should be the IP address and port where headscale is running. In most cases, this will be <code>http://localhost:8080</code>.</p> nginx.conf<pre><code>map $http_upgrade $connection_upgrade {\n    default      upgrade;\n    ''           close;\n}\n\nserver {\n    listen 80;\n    listen [::]:80;\n\n    listen 443      ssl http2;\n    listen [::]:443 ssl http2;\n\n    server_name &lt;YOUR_SERVER_NAME&gt;;\n\n    ssl_certificate &lt;PATH_TO_CERT&gt;;\n    ssl_certificate_key &lt;PATH_CERT_KEY&gt;;\n    ssl_protocols TLSv1.2 TLSv1.3;\n\n    location / {\n        proxy_pass http://&lt;IP:PORT&gt;;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection $connection_upgrade;\n        proxy_set_header Host $server_name;\n        proxy_redirect http:// https://;\n        proxy_buffering off;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        add_header Strict-Transport-Security \"max-age=15552000; includeSubDomains\" always;\n    }\n}\n</code></pre>"},{"location":"ref/integration/reverse-proxy/#istioenvoy","title":"istio/envoy","text":"<p>If you using Istio ingressgateway or Envoy as reverse proxy, there are some tips for you. If not set, you may see some debug log in proxy as below:</p> <pre><code>Sending local reply with details upgrade_failed\n</code></pre>"},{"location":"ref/integration/reverse-proxy/#envoy","title":"Envoy","text":"<p>You need to add a new upgrade_type named <code>tailscale-control-protocol</code>. see details</p>"},{"location":"ref/integration/reverse-proxy/#istio","title":"Istio","text":"<p>Same as envoy, we can use <code>EnvoyFilter</code> to add upgrade_type.</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: headscale-behind-istio-ingress\n  namespace: istio-system\nspec:\n  configPatches:\n    - applyTo: NETWORK_FILTER\n      match:\n        listener:\n          filterChain:\n            filter:\n              name: envoy.filters.network.http_connection_manager\n      patch:\n        operation: MERGE\n        value:\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n            upgrade_configs:\n              - upgrade_type: tailscale-control-protocol\n</code></pre>"},{"location":"ref/integration/reverse-proxy/#caddy","title":"Caddy","text":"<p>The following Caddyfile is all that is necessary to use Caddy as a reverse proxy for headscale, in combination with the <code>config.yaml</code> specifications above to disable headscale's built in TLS. Replace values as necessary - <code>&lt;YOUR_SERVER_NAME&gt;</code> should be the FQDN at which headscale will be served, and <code>&lt;IP:PORT&gt;</code> should be the IP address and port where headscale is running. In most cases, this will be <code>localhost:8080</code>.</p> Caddyfile<pre><code>&lt;YOUR_SERVER_NAME&gt; {\n    reverse_proxy &lt;IP:PORT&gt;\n}\n</code></pre> <p>Caddy v2 will automatically provision a certificate for your domain/subdomain, force HTTPS, and proxy websockets - no further configuration is necessary.</p> <p>For a slightly more complex configuration which utilizes Docker containers to manage Caddy, headscale, and Headscale-UI, Guru Computing's guide is an excellent reference.</p>"},{"location":"ref/integration/reverse-proxy/#apache","title":"Apache","text":"<p>The following minimal Apache config will proxy traffic to the headscale instance on <code>&lt;IP:PORT&gt;</code>. Note that <code>upgrade=any</code> is required as a parameter for <code>ProxyPass</code> so that WebSockets traffic whose <code>Upgrade</code> header value is not equal to <code>WebSocket</code> (i. e. Tailscale Control Protocol) is forwarded correctly. See the Apache docs for more information on this.</p> apache.conf<pre><code>&lt;VirtualHost *:443&gt;\n    ServerName &lt;YOUR_SERVER_NAME&gt;\n\n    ProxyPreserveHost On\n    ProxyPass / http://&lt;IP:PORT&gt;/ upgrade=any\n\n    SSLEngine On\n    SSLCertificateFile &lt;PATH_TO_CERT&gt;\n    SSLCertificateKeyFile &lt;PATH_CERT_KEY&gt;\n&lt;/VirtualHost&gt;\n</code></pre>"},{"location":"ref/integration/tools/","title":"Tools related to headscale","text":"<p>Community contributions</p> <p>This page contains community contributions. The projects listed here are not maintained by the headscale authors and are written by community members.</p> <p>This page collects third-party tools and scripts related to headscale.</p> Name Repository Link Description tailscale-manager Github Dynamically manage Tailscale route advertisements headscalebacktosqlite Github Migrate headscale from PostgreSQL back to SQLite"},{"location":"ref/integration/web-ui/","title":"Web interfaces for headscale","text":"<p>Community contributions</p> <p>This page contains community contributions. The projects listed here are not maintained by the headscale authors and are written by community members.</p> <p>Headscale doesn't provide a built-in web interface but users may pick one from the available options.</p> Name Repository Link Description headscale-webui Github A simple headscale web UI for small-scale deployments. headscale-ui Github A web frontend for the headscale Tailscale-compatible coordination server HeadscaleUi GitHub A static headscale admin ui, no backend environment required Headplane GitHub An advanced Tailscale inspired frontend for headscale headscale-admin Github Headscale-Admin is meant to be a simple, modern web interface for headscale ouroboros Github Ouroboros is designed for users to manage their own devices, rather than for admins <p>You can ask for support on our Discord server in the \"web-interfaces\" channel.</p>"},{"location":"setup/requirements/","title":"Requirements","text":"<p>Headscale should just work as long as the following requirements are met:</p> <ul> <li>A server with a public IP address for headscale. A dual-stack setup with a public IPv4 and a public IPv6 address is   recommended.</li> <li>Headscale is served via HTTPS on port 443<sup>1</sup>.</li> <li>A reasonably modern Linux or BSD based operating system.</li> <li>A dedicated local user account to run headscale.</li> <li>A little bit of command line knowledge to configure and operate headscale.</li> </ul>"},{"location":"setup/requirements/#assumptions","title":"Assumptions","text":"<p>The headscale documentation and the provided examples are written with a few assumptions in mind:</p> <ul> <li>Headscale is running as system service via a dedicated local user <code>headscale</code>.</li> <li>The configuration is loaded from <code>/etc/headscale/config.yaml</code>.</li> <li>SQLite is used as database.</li> <li>The data directory for headscale (used for private keys, ACLs, SQLite database, \u2026) is located in <code>/var/lib/headscale</code>.</li> <li>URLs and values that need to be replaced by the user are either denoted as <code>&lt;VALUE_TO_CHANGE&gt;</code> or use placeholder   values such as <code>headscale.example.com</code>.</li> </ul> <p>Please adjust to your local environment accordingly.</p> <ol> <li> <p>The Tailscale client assumes HTTPS on port 443 in certain situations. Serving headscale either via HTTP or via HTTPS on a port other than 443 is possible but sticking with HTTPS on port 443 is strongly recommended for production setups. See issue 2164 for more information.\u00a0\u21a9</p> </li> </ol>"},{"location":"setup/upgrade/","title":"Upgrade an existing installation","text":"<p>Update an existing headscale installation to a new version:</p> <ul> <li>Read the announcement on the GitHub releases page for the new   version. It lists the changes of the release along with possible breaking changes.</li> <li>Create a backup of your database.</li> <li>Update headscale to the new version, preferably by following the same installation method.</li> <li>Compare and update the configuration file.</li> <li>Restart headscale.</li> </ul>"},{"location":"setup/install/community/","title":"Community packages","text":"<p>Several Linux distributions and community members provide packages for headscale. Those packages may be used instead of the official releases provided by the headscale maintainers. Such packages offer improved integration for their targeted operating system and usually:</p> <ul> <li>setup a dedicated local user account to run headscale</li> <li>provide a default configuration</li> <li>install headscale as system service</li> </ul> <p>Community packages might be outdated</p> <p>The packages mentioned on this page might be outdated or unmaintained. Use the official releases to get the current stable version or to test pre-releases.</p> <p></p>"},{"location":"setup/install/community/#arch-linux","title":"Arch Linux","text":"<p>Arch Linux offers a package for headscale, install via:</p> <pre><code>pacman -S headscale\n</code></pre> <p>The AUR package <code>headscale-git</code> can be used to build the current development version.</p>"},{"location":"setup/install/community/#fedora-rhel-centos","title":"Fedora, RHEL, CentOS","text":"<p>A third-party repository for various RPM based distributions is available at: https://copr.fedorainfracloud.org/coprs/jonathanspw/headscale/. The site provides detailed setup and installation instructions.</p>"},{"location":"setup/install/community/#nix-nixos","title":"Nix, NixOS","text":"<p>A Nix package is available as: <code>headscale</code>. See the NixOS package site for installation details.</p>"},{"location":"setup/install/community/#gentoo","title":"Gentoo","text":"<pre><code>emerge --ask net-vpn/headscale\n</code></pre> <p>Gentoo specific documentation is available here.</p>"},{"location":"setup/install/community/#openbsd","title":"OpenBSD","text":"<p>Headscale is available in ports. The port installs headscale as system service with <code>rc.d</code> and provides usage instructions upon installation.</p> <pre><code>pkg_add headscale\n</code></pre>"},{"location":"setup/install/container/","title":"Running headscale in a container","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by headscale developers.</p> <p>It might be outdated and it might miss necessary steps.</p> <p>This documentation has the goal of showing a user how-to set up and run headscale in a container. Docker is used as the reference container implementation, but there is no reason that it should not work with alternatives like Podman. The Docker image can be found on Docker Hub here.</p>"},{"location":"setup/install/container/#configure-and-run-headscale","title":"Configure and run headscale","text":"<ol> <li> <p>Prepare a directory on the host Docker node in your directory of choice, used to hold headscale configuration and the SQLite database:</p> <pre><code>mkdir -p ./headscale/config\ncd ./headscale\n</code></pre> </li> <li> <p>Download the example configuration for your chosen version and save it as: <code>/etc/headscale/config.yaml</code>. Adjust the     configuration to suit your local environment. See Configuration for details.</p> <pre><code>sudo mkdir -p /etc/headscale\nsudo nano /etc/headscale/config.yaml\n</code></pre> <p>Alternatively, you can mount <code>/var/lib</code> and <code>/var/run</code> from your host system by adding <code>--volume $(pwd)/lib:/var/lib/headscale</code> and <code>--volume $(pwd)/run:/var/run/headscale</code> in the next step.</p> </li> <li> <p>Start the headscale server while working in the host headscale directory:</p> <pre><code>docker run \\\n  --name headscale \\\n  --detach \\\n  --volume $(pwd)/config:/etc/headscale/ \\\n  --publish 127.0.0.1:8080:8080 \\\n  --publish 127.0.0.1:9090:9090 \\\n  headscale/headscale:&lt;VERSION&gt; \\\n  serve\n</code></pre> <p>Note: use <code>0.0.0.0:8080:8080</code> instead of <code>127.0.0.1:8080:8080</code> if you want to expose the container externally.</p> <p>This command will mount <code>config/</code> under <code>/etc/headscale</code>, forward port 8080 out of the container so the headscale instance becomes available and then detach so headscale runs in the background.</p> <p>Example <code>docker-compose.yaml</code></p> <pre><code>version: \"3.7\"\n\nservices:\n  headscale:\n    image: headscale/headscale:&lt;VERSION&gt;\n    restart: unless-stopped\n    container_name: headscale\n    ports:\n      - \"127.0.0.1:8080:8080\"\n      - \"127.0.0.1:9090:9090\"\n    volumes:\n      # Please change &lt;CONFIG_PATH&gt; to the fullpath of the config folder just created\n      - &lt;CONFIG_PATH&gt;:/etc/headscale\n    command: serve\n</code></pre> </li> <li> <p>Verify headscale is running:</p> <p>Follow the container logs:</p> <pre><code>docker logs --follow headscale\n</code></pre> <p>Verify running containers:</p> <pre><code>docker ps\n</code></pre> <p>Verify headscale is available:</p> <pre><code>curl http://127.0.0.1:9090/metrics\n</code></pre> </li> <li> <p>Create a headscale user:</p> <pre><code>docker exec -it headscale \\\n  headscale users create myfirstuser\n</code></pre> </li> </ol>"},{"location":"setup/install/container/#register-a-machine-normal-login","title":"Register a machine (normal login)","text":"<p>On a client machine, execute the <code>tailscale</code> login command:</p> <pre><code>tailscale up --login-server YOUR_HEADSCALE_URL\n</code></pre> <p>To register a machine when running headscale in a container, take the headscale command and pass it to the container:</p> <pre><code>docker exec -it headscale \\\n  headscale nodes register --user myfirstuser --key &lt;YOUR_MACHINE_KEY&gt;\n</code></pre>"},{"location":"setup/install/container/#register-machine-using-a-pre-authenticated-key","title":"Register machine using a pre authenticated key","text":"<p>Generate a key using the command line:</p> <pre><code>docker exec -it headscale \\\n  headscale preauthkeys create --user myfirstuser --reusable --expiration 24h\n</code></pre> <p>This will return a pre-authenticated key that can be used to connect a node to headscale during the <code>tailscale</code> command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --authkey &lt;YOUR_AUTH_KEY&gt;\n</code></pre>"},{"location":"setup/install/container/#debugging-headscale-running-in-docker","title":"Debugging headscale running in Docker","text":"<p>The <code>headscale/headscale</code> Docker container is based on a \"distroless\" image that does not contain a shell or any other debug tools. If you need to debug your application running in the Docker container, you can use the <code>-debug</code> variant, for example <code>headscale/headscale:x.x.x-debug</code>.</p>"},{"location":"setup/install/container/#running-the-debug-docker-container","title":"Running the debug Docker container","text":"<p>To run the debug Docker container, use the exact same commands as above, but replace <code>headscale/headscale:x.x.x</code> with <code>headscale/headscale:x.x.x-debug</code> (<code>x.x.x</code> is the version of headscale). The two containers are compatible with each other, so you can alternate between them.</p>"},{"location":"setup/install/container/#executing-commands-in-the-debug-container","title":"Executing commands in the debug container","text":"<p>The default command in the debug container is to run <code>headscale</code>, which is located at <code>/ko-app/headscale</code> inside the container.</p> <p>Additionally, the debug container includes a minimalist Busybox shell.</p> <p>To launch a shell in the container, use:</p> <pre><code>docker run -it headscale/headscale:x.x.x-debug sh\n</code></pre> <p>You can also execute commands directly, such as <code>ls /ko-app</code> in this example:</p> <pre><code>docker run headscale/headscale:x.x.x-debug ls /ko-app\n</code></pre> <p>Using <code>docker exec -it</code> allows you to run commands in an existing container.</p>"},{"location":"setup/install/official/","title":"Official releases","text":"<p>Official releases for headscale are available as binaries for various platforms and DEB packages for Debian and Ubuntu. Both are available on the GitHub releases page.</p>"},{"location":"setup/install/official/#using-packages-for-debianubuntu-recommended","title":"Using packages for Debian/Ubuntu (recommended)","text":"<p>It is recommended to use our DEB packages to install headscale on a Debian based system as those packages configure a local user to run headscale, provide a default configuration and ship with a systemd service file. Supported distributions are Ubuntu 20.04 or newer, Debian 11 or newer.</p> <ol> <li> <p>Download the latest headscale package for your platform (<code>.deb</code> for Ubuntu and Debian).</p> <pre><code>HEADSCALE_VERSION=\"\" # See above URL for latest version, e.g. \"X.Y.Z\" (NOTE: do not add the \"v\" prefix!)\nHEADSCALE_ARCH=\"\" # Your system architecture, e.g. \"amd64\"\nwget --output-document=headscale.deb \\\n \"https://github.com/juanfont/headscale/releases/download/v${HEADSCALE_VERSION}/headscale_${HEADSCALE_VERSION}_linux_${HEADSCALE_ARCH}.deb\"\n</code></pre> </li> <li> <p>Install headscale:</p> <pre><code>sudo apt install ./headscale.deb\n</code></pre> </li> <li> <p>Configure headscale by editing the configuration file:</p> <pre><code>sudo nano /etc/headscale/config.yaml\n</code></pre> </li> <li> <p>Enable and start the headscale service:</p> <pre><code>sudo systemctl enable --now headscale\n</code></pre> </li> <li> <p>Verify that headscale is running as intended:</p> <pre><code>sudo systemctl status headscale\n</code></pre> </li> </ol>"},{"location":"setup/install/official/#using-standalone-binaries-advanced","title":"Using standalone binaries (advanced)","text":"<p>Advanced</p> <p>This installation method is considered advanced as one needs to take care of the local user and the systemd service themselves. If possible, use the DEB packages or a community package instead.</p> <p>This section describes the installation of headscale according to the Requirements and assumptions. Headscale is run by a dedicated local user and the service itself is managed by systemd.</p> <ol> <li> <p>Download the latest <code>headscale</code> binary from GitHub's release page:</p> <pre><code>sudo wget --output-document=/usr/local/bin/headscale \\\nhttps://github.com/juanfont/headscale/releases/download/v&lt;HEADSCALE VERSION&gt;/headscale_&lt;HEADSCALE VERSION&gt;_linux_&lt;ARCH&gt;\n</code></pre> </li> <li> <p>Make <code>headscale</code> executable:</p> <pre><code>sudo chmod +x /usr/local/bin/headscale\n</code></pre> </li> <li> <p>Add a dedicated local user to run headscale:</p> <pre><code>sudo useradd \\\n --create-home \\\n --home-dir /var/lib/headscale/ \\\n --system \\\n --user-group \\\n --shell /usr/sbin/nologin \\\n headscale\n</code></pre> </li> <li> <p>Download the example configuration for your chosen version and save it as: <code>/etc/headscale/config.yaml</code>. Adjust the     configuration to suit your local environment. See Configuration for details.</p> <pre><code>sudo mkdir -p /etc/headscale\nsudo nano /etc/headscale/config.yaml\n</code></pre> </li> <li> <p>Copy headscale's systemd service file to     <code>/etc/systemd/system/headscale.service</code> and adjust it to suit your local setup. The following parameters likely need     to be modified: <code>ExecStart</code>, <code>WorkingDirectory</code>, <code>ReadWritePaths</code>.</p> </li> <li> <p>In <code>/etc/headscale/config.yaml</code>, override the default <code>headscale</code> unix socket with a path that is writable by the     <code>headscale</code> user or group:</p> config.yaml<pre><code>unix_socket: /var/run/headscale/headscale.sock\n</code></pre> </li> <li> <p>Reload systemd to load the new configuration file:</p> <pre><code>systemctl daemon-reload\n</code></pre> </li> <li> <p>Enable and start the new headscale service:</p> <pre><code>systemctl enable --now headscale\n</code></pre> </li> <li> <p>Verify that headscale is running as intended:</p> <pre><code>systemctl status headscale\n</code></pre> </li> </ol>"},{"location":"setup/install/source/","title":"Build from source","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by headscale developers.</p> <p>It might be outdated and it might miss necessary steps.</p> <p>Headscale can be built from source using the latest version of Go and Buf (Protobuf generator). See the Contributing section in the GitHub README for more information.</p>"},{"location":"setup/install/source/#openbsd","title":"OpenBSD","text":""},{"location":"setup/install/source/#install-from-source","title":"Install from source","text":"<pre><code># Install prerequisites\npkg_add go\n\ngit clone https://github.com/juanfont/headscale.git\n\ncd headscale\n\n# optionally checkout a release\n# option a. you can find official release at https://github.com/juanfont/headscale/releases/latest\n# option b. get latest tag, this may be a beta release\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\n\ngit checkout $latestTag\n\ngo build -ldflags=\"-s -w -X github.com/juanfont/headscale/hscontrol/types.Version=$latestTag\" -X github.com/juanfont/headscale/hscontrol/types.GitCommitHash=HASH\" github.com/juanfont/headscale\n\n# make it executable\nchmod a+x headscale\n\n# copy it to /usr/local/sbin\ncp headscale /usr/local/sbin\n</code></pre>"},{"location":"setup/install/source/#install-from-source-via-cross-compile","title":"Install from source via cross compile","text":"<pre><code># Install prerequisites\n# 1. go v1.20+: headscale newer than 0.21 needs go 1.20+ to compile\n# 2. gmake: Makefile in the headscale repo is written in GNU make syntax\n\ngit clone https://github.com/juanfont/headscale.git\n\ncd headscale\n\n# optionally checkout a release\n# option a. you can find official release at https://github.com/juanfont/headscale/releases/latest\n# option b. get latest tag, this may be a beta release\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\n\ngit checkout $latestTag\n\nmake build GOOS=openbsd\n\n# copy headscale to openbsd machine and put it in /usr/local/sbin\n</code></pre>"},{"location":"usage/getting-started/","title":"Getting started","text":"<p>This page helps you get started with headscale and provides a few usage examples for the headscale command line tool <code>headscale</code>.</p> <p>Prerequisites</p> <ul> <li>Headscale is installed and running as system service. Read the setup section for   installation instructions.</li> <li>The configuration file exists and is adjusted to suit your environment, see   Configuration for details.</li> <li>Headscale is reachable from the Internet. Verify this by opening client specific setup instructions in your   browser, e.g. https://headscale.example.com/windows</li> <li>The Tailscale client is installed, see Client and operating system support for more   information.</li> </ul>"},{"location":"usage/getting-started/#getting-help","title":"Getting help","text":"<p>The <code>headscale</code> command line tool provides built-in help. To show available commands along with their arguments and options, run:</p> NativeContainer <pre><code># Show help\nheadscale help\n\n# Show help for a specific command\nheadscale &lt;COMMAND&gt; --help\n</code></pre> <pre><code># Show help\ndocker exec -it headscale \\\n  headscale help\n\n# Show help for a specific command\ndocker exec -it headscale \\\n  headscale &lt;COMMAND&gt; --help\n</code></pre>"},{"location":"usage/getting-started/#manage-headscale-users","title":"Manage headscale users","text":"<p>In headscale, a node (also known as machine or device) is always assigned to a headscale user. Such a headscale user may have many nodes assigned to them and can be managed with the <code>headscale users</code> command. Invoke the built-in help for more information: <code>headscale users --help</code>.</p>"},{"location":"usage/getting-started/#create-a-headscale-user","title":"Create a headscale user","text":"NativeContainer <pre><code>headscale users create &lt;USER&gt;\n</code></pre> <pre><code>docker exec -it headscale \\\n  headscale users create &lt;USER&gt;\n</code></pre>"},{"location":"usage/getting-started/#list-existing-headscale-users","title":"List existing headscale users","text":"NativeContainer <pre><code>headscale users list\n</code></pre> <pre><code>docker exec -it headscale \\\n  headscale users list\n</code></pre>"},{"location":"usage/getting-started/#register-a-node","title":"Register a node","text":"<p>One has to register a node first to use headscale as coordination with Tailscale. The following examples work for the Tailscale client on Linux/BSD operating systems. Alternatively, follow the instructions to connect Android, Apple or Windows devices.</p>"},{"location":"usage/getting-started/#normal-interactive-login","title":"Normal, interactive login","text":"<p>On a client machine, run the <code>tailscale up</code> command and provide the FQDN of your headscale instance as argument:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt;\n</code></pre> <p>Usually, a browser window with further instructions is opened and contains the value for <code>&lt;YOUR_MACHINE_KEY&gt;</code>. Approve and register the node on your headscale server:</p> NativeContainer <pre><code>headscale nodes register --user &lt;USER&gt; --key &lt;YOUR_MACHINE_KEY&gt;\n</code></pre> <pre><code>docker exec -it headscale \\\n  headscale nodes register --user &lt;USER&gt; --key &lt;YOUR_MACHINE_KEY&gt;\n</code></pre>"},{"location":"usage/getting-started/#using-a-preauthkey","title":"Using a preauthkey","text":"<p>It is also possible to generate a preauthkey and register a node non-interactively. First, generate a preauthkey on the headscale instance. By default, the key is valid for one hour and can only be used once (see <code>headscale preauthkeys --help</code> for other options):</p> NativeContainer <pre><code>headscale preauthkeys create --user &lt;USER&gt;\n</code></pre> <pre><code>docker exec -it headscale \\\n  headscale preauthkeys create --user &lt;USER&gt;\n</code></pre> <p>The command returns the preauthkey on success which is used to connect a node to the headscale instance via the <code>tailscale up</code> command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --authkey &lt;YOUR_AUTH_KEY&gt;\n</code></pre>"},{"location":"usage/connect/android/","title":"Connecting an Android client","text":"<p>This documentation has the goal of showing how a user can use the official Android Tailscale client with headscale.</p>"},{"location":"usage/connect/android/#installation","title":"Installation","text":"<p>Install the official Tailscale Android client from the Google Play Store or F-Droid.</p>"},{"location":"usage/connect/android/#configuring-the-headscale-url","title":"Configuring the headscale URL","text":"<ul> <li>Open the app and select the settings menu in the upper-right corner</li> <li>Tap on <code>Accounts</code></li> <li>In the kebab menu icon (three dots) in the upper-right corner select <code>Use an alternate server</code></li> <li>Enter your server URL (e.g <code>https://headscale.example.com</code>) and follow the instructions</li> </ul>"},{"location":"usage/connect/apple/","title":"Connecting an Apple client","text":"<p>This documentation has the goal of showing how a user can use the official iOS and macOS Tailscale clients with headscale.</p> <p>Instructions on your headscale instance</p> <p>An endpoint with information on how to connect your Apple device is also available at <code>/apple</code> on your running instance.</p>"},{"location":"usage/connect/apple/#ios","title":"iOS","text":""},{"location":"usage/connect/apple/#installation","title":"Installation","text":"<p>Install the official Tailscale iOS client from the App Store.</p>"},{"location":"usage/connect/apple/#configuring-the-headscale-url","title":"Configuring the headscale URL","text":"<ul> <li>Open the Tailscale app</li> <li>Click the account icon in the top-right corner and select <code>Log in\u2026</code>.</li> <li>Tap the top-right options menu button and select <code>Use custom coordination server</code>.</li> <li>Enter your instance url (e.g <code>https://headscale.example.com</code>)</li> <li>Enter your credentials and log in. Headscale should now be working on your iOS device.</li> </ul>"},{"location":"usage/connect/apple/#macos","title":"macOS","text":""},{"location":"usage/connect/apple/#installation_1","title":"Installation","text":"<p>Choose one of the available Tailscale clients for macOS and install it.</p>"},{"location":"usage/connect/apple/#configuring-the-headscale-url_1","title":"Configuring the headscale URL","text":""},{"location":"usage/connect/apple/#command-line","title":"Command line","text":"<p>Use Tailscale's login command to connect with your headscale instance (e.g <code>https://headscale.example.com</code>):</p> <pre><code>tailscale login --login-server &lt;YOUR_HEADSCALE_URL&gt;\n</code></pre>"},{"location":"usage/connect/apple/#gui","title":"GUI","text":"<ul> <li>Option + Click the Tailscale icon in the menu and hover over the Debug menu</li> <li>Under <code>Custom Login Server</code>, select <code>Add Account...</code></li> <li>Enter the URL of your headscale instance (e.g <code>https://headscale.example.com</code>) and press <code>Add Account</code></li> <li>Follow the login procedure in the browser</li> </ul>"},{"location":"usage/connect/apple/#tvos","title":"tvOS","text":""},{"location":"usage/connect/apple/#installation_2","title":"Installation","text":"<p>Install the official Tailscale tvOS client from the App Store.</p> <p>Danger</p> <p>Don't open the Tailscale App after installation!</p>"},{"location":"usage/connect/apple/#configuring-the-headscale-url_2","title":"Configuring the headscale URL","text":"<ul> <li>Open Settings (the Apple tvOS settings) &gt; Apps &gt; Tailscale</li> <li>Under <code>ALTERNATE COORDINATION SERVER URL</code>, select <code>URL</code></li> <li>Enter the URL of your headscale instance (e.g <code>https://headscale.example.com</code>) and press <code>OK</code></li> <li>Return to the tvOS Home screen</li> <li>Open Tailscale</li> <li>Click the button <code>Install VPN configuration</code> and confirm the appearing popup by clicking the <code>Allow</code> button</li> <li>Scan the QR code and follow the login procedure</li> </ul>"},{"location":"usage/connect/windows/","title":"Connecting a Windows client","text":"<p>This documentation has the goal of showing how a user can use the official Windows Tailscale client with headscale.</p> <p>Instructions on your headscale instance</p> <p>An endpoint with information on how to connect your Windows device is also available at <code>/windows</code> on your running instance.</p>"},{"location":"usage/connect/windows/#installation","title":"Installation","text":"<p>Download the Official Windows Client and install it.</p>"},{"location":"usage/connect/windows/#configuring-the-headscale-url","title":"Configuring the headscale URL","text":"<p>Open a Command Prompt or Powershell and use Tailscale's login command to connect with your headscale instance (e.g <code>https://headscale.example.com</code>):</p> <pre><code>tailscale login --login-server &lt;YOUR_HEADSCALE_URL&gt;\n</code></pre> <p>Follow the instructions in the opened browser window to finish the configuration.</p>"},{"location":"usage/connect/windows/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/connect/windows/#unattended-mode","title":"Unattended mode","text":"<p>By default, Tailscale's Windows client is only running when the user is logged in. If you want to keep Tailscale running all the time, please enable \"Unattended mode\":</p> <ul> <li>Click on the Tailscale tray icon and select <code>Preferences</code></li> <li>Enable <code>Run unattended</code></li> <li>Confirm the \"Unattended mode\" message</li> </ul> <p>See also Keep Tailscale running when I'm not logged in to my computer</p>"},{"location":"usage/connect/windows/#failing-node-registration","title":"Failing node registration","text":"<p>If you are seeing repeated messages like:</p> <pre><code>[GIN] 2022/02/10 - 16:39:34 | 200 |    1.105306ms |       127.0.0.1 | POST     \"/machine/redacted\"\n</code></pre> <p>in your headscale output, turn on <code>DEBUG</code> logging and look for:</p> <pre><code>2022-02-11T00:59:29Z DBG Machine registration has expired. Sending a authurl to register machine=redacted\n</code></pre> <p>This typically means that the registry keys above was not set appropriately.</p> <p>To reset and try again, it is important to do the following:</p> <ol> <li>Shut down the Tailscale service (or the client running in the tray)</li> <li>Delete Tailscale Application data folder, located at <code>C:\\Users\\&lt;USERNAME&gt;\\AppData\\Local\\Tailscale</code> and try to connect again.</li> <li>Ensure the Windows node is deleted from headscale (to ensure fresh setup)</li> <li>Start Tailscale on the Windows machine and retry the login.</li> </ol>"}]}